/*Реализовать паттерн проектирования «Адаптер» на любом примере.

Описание: паттерн Adapter позволяет сконвертировать интерфейс одного класса в интерфейс другого, который ожидает клиент.

Продемонстрируйте на простом примере в Go: у вас есть существующий интерфейс (или структура) и другой, несовместимый по интерфейсу потребитель — напишите адаптер, который реализует нужный интерфейс и делегирует вызовы к встроенному объекту.

Поясните применимость паттерна, его плюсы и минусы, а также приведите реальные примеры использования.*/

package main

/* паттерн Адаптер используется: - когда интерфес стороннего объекта не соответствует индерфейсу других объектов
- когда нужно испоьзовать обект, интерфейс которого не соответствует каким-то требованиям

Плюсы: поддержка принципа SOLID, повторяемость.

минусы: дполнительные абстракции (повышается сложность), отдельное пкрытие тестами.
*/

import "fmt"

//существует интерфейс animal, который имееет метод getVoice

type animal interface {
	getVoice()
}

//существует тип dog, который не удовлетворяет интерфесу animal
type dog struct {
}

//у собаки есть метод wow -  подача голоса
func (d *dog) wow() {
	fmt.Println("the dog say: wow-wow-wow")
}

//чтобы наша собака удовлетворяла интрефейсу animal необходим адаптер(сущность)
//создаем адаптер, содержащий поле - нашу собаку
type dogToAnimal struct {
	d *dog
}

//создаем метод getVoice для адаптера, чтобы он соотвествовал нашему интерфейсу animal
func (dg dogToAnimal) getVoice() {
	dg.d.wow()
}

//voice - функция, возвращающая голос животного
func voice(a animal) {
	a.getVoice()
}

func main() {

	//созадем экземпляр структуры dog
	druzok := dog{}

	//создаем экземпляр структуры-адаптера
	animalDog := dogToAnimal{
		d: &druzok,
	}

	fmt.Println("what does the dog say?")
	//вызываем функцию voice для полуения гооса нашей собаки

	voice(animalDog)
}
